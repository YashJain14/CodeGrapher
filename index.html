<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Physics-Based Circle Packing Code Graph</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: radial-gradient(circle at center, #1a1a2e 0%, #16213e 50%, #0f1419 100%);
            color: #fff;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(20px);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 380px;
            transition: all 0.3s ease;
        }
        
        #controls.hidden {
            transform: translateX(-100%);
            opacity: 0;
            pointer-events: none;
        }
        
        #info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(20px);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            max-width: 420px;
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: all 0.3s ease;
        }
        
        #info.hidden {
            transform: translateX(100%);
            opacity: 0;
            pointer-events: none;
        }
        
        #fileInput {
            display: none;
        }
        
        .load-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 10px;
            cursor: pointer;
            margin-bottom: 20px;
            font-size: 14px;
            font-weight: 600;
            width: 100%;
            transition: all 0.3s ease;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.3);
        }
        
        .load-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(102, 126, 234, 0.4);
        }
        
        h3 {
            margin-top: 0;
            color: #fff;
            font-weight: 600;
            font-size: 18px;
        }
        
        .circle-node {
            cursor: pointer;
            transition: filter 0.2s ease;
        }
        
        .circle-node:hover {
            filter: brightness(1.2) drop-shadow(0 0 10px rgba(255,255,255,0.3));
        }
        
        .circle-file {
            fill-opacity: 0.12;
            stroke-width: 3;
            stroke-dasharray: 10,5;
            filter: drop-shadow(0 0 8px rgba(255,107,107,0.3));
        }
        
        .circle-class {
            fill-opacity: 0.3;
            stroke-width: 2.5;
            filter: drop-shadow(0 0 6px rgba(78,205,196,0.3));
        }
        
        .circle-interface {
            fill-opacity: 0.3;
            stroke-width: 2.5;
            stroke-dasharray: 6,3;
            filter: drop-shadow(0 0 6px rgba(0,206,209,0.3));
        }
        
        .circle-method, .circle-function {
            fill-opacity: 0.85;
            stroke-width: 2;
            stroke: rgba(255,255,255,0.8);
            filter: drop-shadow(0 0 4px rgba(255,255,255,0.2));
        }
        
        .circle-import {
            fill-opacity: 0.75;
            stroke-width: 1.5;
            stroke: rgba(255,255,255,0.6);
            filter: drop-shadow(0 0 3px rgba(221,160,221,0.3));
        }
        
        .node-label {
            font-size: 11px;
            pointer-events: none;
            fill: #fff;
            text-shadow: 0 0 6px rgba(0,0,0,0.8), 0 0 3px rgba(0,0,0,1);
            font-weight: 500;
            dominant-baseline: middle;
            text-anchor: middle;
        }
        
        .container-label {
            font-size: 13px;
            pointer-events: none;
            fill: #fff;
            text-shadow: 0 0 8px rgba(0,0,0,0.9), 0 0 4px rgba(0,0,0,1);
            font-weight: 600;
            dominant-baseline: middle;
            text-anchor: middle;
        }
        
        .connection-line {
            fill: none;
            stroke-opacity: 0.5;
            transition: all 0.3s ease;
        }
        
        .connection-line:hover {
            stroke-opacity: 0.9;
            stroke-width: 3 !important;
            filter: drop-shadow(0 0 5px currentColor);
        }
        
        .connection-calls {
            stroke: #45b7d1;
            stroke-width: 2;
        }
        
        .connection-inherits {
            stroke: #ff6b6b;
            stroke-width: 2.5;
            stroke-dasharray: 8,4;
        }
        
        .connection-implements {
            stroke: #4ecdc4;
            stroke-width: 2.5;
            stroke-dasharray: 4,4;
        }
        
        .connection-instantiates {
            stroke: #ffa500;
            stroke-width: 2;
        }
        
        button {
            margin: 4px 2px;
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s ease;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }
        
        button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.active {
            background: rgba(102, 126, 234, 0.3);
            border-color: rgba(102, 126, 234, 0.5);
        }
        
        #search {
            width: 100%;
            padding: 12px 16px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.08);
            color: white;
            font-size: 14px;
            font-weight: 500;
        }
        
        #search::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        
        #search:focus {
            outline: none;
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.1);
        }
        
        label {
            display: flex;
            align-items: center;
            margin: 8px 0;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
        }
        
        input[type="checkbox"] {
            margin-right: 10px;
            cursor: pointer;
            transform: scale(1.1);
        }
        
        .button-group {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .button-group button {
            flex: 1;
            min-width: 85px;
        }
        
        #nodeInfo {
            font-size: 14px;
            line-height: 1.6;
        }
        
        #nodeInfo strong {
            color: #4ecdc4;
        }
        
        .tooltip {
            position: absolute;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.92);
            border-radius: 10px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 2000;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        }
        
        #stats {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 13px;
            line-height: 1.6;
        }
        
        .legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(20px);
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            transition: all 0.3s ease;
        }
        
        .legend.hidden {
            transform: translateX(-100%);
            opacity: 0;
            pointer-events: none;
        }
        
        #uiToggle {
            position: absolute;
            top: 50%;
            left: 10px;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 15px 8px;
            border-radius: 0 10px 10px 0;
            cursor: pointer;
            font-size: 16px;
            z-index: 1001;
            transition: all 0.3s ease;
            writing-mode: vertical-rl;
            text-orientation: mixed;
        }
        
        #uiToggle:hover {
            background: rgba(0, 0, 0, 0.9);
            padding-left: 12px;
        }
        
        #uiToggle.hidden {
            left: -2px;
            border-radius: 0 8px 8px 0;
            padding: 10px 6px;
        }
        
        .legend h4 {
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 16px;
            font-weight: 600;
        }
        
        .legend-section {
            margin-bottom: 15px;
        }
        
        .legend-section:last-child {
            margin-bottom: 0;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
            font-size: 12px;
        }
        
        .legend-color {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            margin-right: 12px;
            display: inline-block;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }
        
        .legend-line {
            margin-right: 12px;
        }
        
        .highlighted {
            stroke: #fff !important;
            stroke-width: 4 !important;
            filter: brightness(1.4) drop-shadow(0 0 15px rgba(255,255,255,0.6)) !important;
        }
        
        .dimmed {
            opacity: 0.25 !important;
            filter: grayscale(0.3) !important;
        }
        
        .section-title {
            font-weight: 600;
            color: #4ecdc4;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .physics-controls {
            margin-bottom: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .physics-controls label {
            margin: 5px 0;
            font-size: 12px;
        }
        
        .physics-controls input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }
        
        .circular-boundary {
            fill: none;
            stroke: rgba(255, 255, 255, 0.1);
            stroke-width: 2;
            stroke-dasharray: 10,10;
            opacity: 0.3;
        }
    </style>
</head>
<body>
    <div id="container">
        <svg id="graph"></svg>
        
        <button id="uiToggle" onclick="toggleUI()">üéõÔ∏è</button>
        
        <div id="controls">
            <input type="file" id="fileInput" accept=".json">
            <button class="load-button" onclick="document.getElementById('fileInput').click()">
                üìÅ Load code_graph.json
            </button>
            
            <input type="text" id="search" placeholder="üîç Search nodes...">
            
            <div class="button-group">
                <button onclick="zoomIn()">üîç Zoom In</button>
                <button onclick="zoomOut()">üîç Zoom Out</button>
                <button onclick="resetZoom()">üè† Reset</button>
            </div>
            
            <div class="button-group">
                <button onclick="centerGraph()">üìç Center</button>
                <button id="physicsBtn" onclick="togglePhysics()" class="active">‚ö° Physics</button>
                <button onclick="resetPositions()">üîÑ Scatter</button>
            </div>
            
            <div class="button-group">
                <button onclick="toggleConnections()">üîó Links</button>
                <button onclick="highlightCrossFileConnections()">üåê Cross-File</button>
            </div>
            
            <div class="physics-controls">
                <div class="section-title">Physics Settings</div>
                <label>
                    Gravity: <span id="gravityValue">0.005</span>
                    <input type="range" id="gravitySlider" min="0" max="0.05" step="0.002" value="0.005">
                </label>
                <label>
                    Repulsion: <span id="chargeValue">-300</span>
                    <input type="range" id="chargeSlider" min="-800" max="-50" step="25" value="-300">
                </label>
                <label>
                    Link Strength: <span id="linkValue">0.05</span>
                    <input type="range" id="linkSlider" min="0.01" max="0.3" step="0.01" value="0.05">
                </label>
                <label>
                    Collision Padding: <span id="collisionValue">40</span>
                    <input type="range" id="collisionSlider" min="10" max="100" step="5" value="40">
                </label>
                <label>
                    <input type="checkbox" id="enablePhysics" checked> Enable Physics
                </label>
                <label>
                    <input type="checkbox" id="highPerformance" checked> High Performance Mode
                </label>
            </div>
            
            <div class="section-title">Node Types</div>
            <label><input type="checkbox" id="showFiles" checked> üìÑ Files</label>
            <label><input type="checkbox" id="showClasses" checked> üèóÔ∏è Classes</label>
            <label><input type="checkbox" id="showMethods" checked> ‚öôÔ∏è Methods</label>
            <label><input type="checkbox" id="showFunctions" checked> üîß Functions</label>
            <label><input type="checkbox" id="showImports" checked> üì¶ Imports</label>
            
            <div id="stats"></div>
        </div>
        
        <div id="info">
            <h3>Node Information</h3>
            <div id="nodeInfo">Load a JSON file to start exploring your code structure with physics-based visualization.</div>
        </div>
        
        <div class="legend">
            <h4>Legend</h4>
            
            <div class="legend-section">
                <div class="section-title">Node Types:</div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #FF6B6B; opacity: 0.3; border: 2px dashed #FF6B6B;"></div>
                    <span>File Container</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #4ECDC4; opacity: 0.5;"></div>
                    <span>Class Container</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #45B7D1;"></div>
                    <span>Method</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #96CEB4;"></div>
                    <span>Function</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: #DDA0DD;"></div>
                    <span>Import</span>
                </div>
            </div>
            
            <div class="legend-section">
                <div class="section-title">Relationships:</div>
                <div class="legend-item">
                    <svg class="legend-line" width="30" height="3">
                        <line x1="0" y1="1.5" x2="30" y2="1.5" stroke="#45b7d1" stroke-width="2"/>
                    </svg>
                    <span>Calls</span>
                </div>
                <div class="legend-item">
                    <svg class="legend-line" width="30" height="3">
                        <line x1="0" y1="1.5" x2="30" y2="1.5" stroke="#ffa500" stroke-width="2"/>
                    </svg>
                    <span>Creates/Uses</span>
                </div>
                <div class="legend-item">
                    <svg class="legend-line" width="30" height="3">
                        <line x1="0" y1="1.5" x2="30" y2="1.5" stroke="#ff6b6b" stroke-width="2" stroke-dasharray="8,4"/>
                    </svg>
                    <span>Inherits</span>
                </div>
                <div class="legend-item">
                    <svg class="legend-line" width="30" height="3">
                        <line x1="0" y1="1.5" x2="30" y2="1.5" stroke="#4ecdc4" stroke-width="2" stroke-dasharray="4,4"/>
                    </svg>
                    <span>Implements</span>
                </div>
            </div>
        </div>
        
        <div class="tooltip"></div>
    </div>
    
    <script>
        // Global variables
        let graphData = null;
        let svg = null;
        let g = null;
        let zoom = null;
        let simulation = null;
        let showConnections = true;
        let physicsEnabled = true;
        let uiVisible = true;
        let nodes = [];
        let connections = [];
        let circleElements = null;
        let connectionElements = null;
        let labelElements = null;
        let boundaryCircle = null;
        
        // Performance optimization variables
        let lastTickTime = 0;
        let tickThrottle = 16; // ~60fps max
        let isSimulationCooled = false;
        let frameRequestId = null;
        
        // Physics parameters - MUCH more spread out defaults
        let gravityStrength = 0.005; // Much weaker gravity
        let chargeStrength = -300; // Stronger repulsion
        let linkStrength = 0.05; // Weaker links
        let collisionPadding = 40; // Much more collision padding
        
        // Color mapping
        const colorMap = {
            'file': '#FF6B6B',
            'class': '#4ECDC4',
            'interface': '#00CED1',
            'method': '#45B7D1',
            'function': '#96CEB4',
            'variable': '#FECA57',
            'import': '#DDA0DD',
            'module': '#98D8C8',
            'package': '#FFB6C1'
        };
        
        // File input handler
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        graphData = JSON.parse(e.target.result);
                        initializeGraph();
                        updateStats();
                    } catch (error) {
                        alert('Error loading JSON file: ' + error.message);
                    }
                };
                reader.readAsText(file);
            }
        });
        
        // Physics controls
        document.getElementById('gravitySlider').addEventListener('input', function(e) {
            gravityStrength = parseFloat(e.target.value);
            document.getElementById('gravityValue').textContent = gravityStrength;
            throttledUpdatePhysics();
        });
        
        document.getElementById('chargeSlider').addEventListener('input', function(e) {
            chargeStrength = parseInt(e.target.value);
            document.getElementById('chargeValue').textContent = chargeStrength;
            throttledUpdatePhysics();
        });
        
        document.getElementById('linkSlider').addEventListener('input', function(e) {
            linkStrength = parseFloat(e.target.value);
            document.getElementById('linkValue').textContent = linkStrength;
            throttledUpdatePhysics();
        });
        
        document.getElementById('collisionSlider').addEventListener('input', function(e) {
            collisionPadding = parseInt(e.target.value);
            document.getElementById('collisionValue').textContent = collisionPadding;
            throttledUpdatePhysics();
        });
        
        document.getElementById('enablePhysics').addEventListener('change', function(e) {
            physicsEnabled = e.target.checked;
            if (physicsEnabled) {
                simulation?.restart();
            } else {
                simulation?.stop();
            }
        });
        
        document.getElementById('highPerformance').addEventListener('change', function(e) {
            tickThrottle = e.target.checked ? 33 : 16; // 30fps vs 60fps
        });
        
        // Throttled physics update to prevent excessive recalculation
        let physicsUpdateTimeout;
        function throttledUpdatePhysics() {
            clearTimeout(physicsUpdateTimeout);
            physicsUpdateTimeout = setTimeout(updatePhysics, 100);
        }
        
        function updatePhysics() {
            if (simulation && physicsEnabled) {
                const nodeCount = nodes.length;
                
                // Better spacing calculations
                const isLargeGraph = nodeCount > 100;
                const isMassiveGraph = nodeCount > 500;
                
                // Adaptive parameters for better spacing
                const adaptiveCharge = isMassiveGraph ? 
                    Math.max(chargeStrength * 3, -900) : 
                    isLargeGraph ? 
                    Math.max(chargeStrength * 2, -600) : 
                    chargeStrength;
                
                const adaptiveCollision = Math.max(collisionPadding * 1.5, 
                    isMassiveGraph ? 80 : isLargeGraph ? 60 : 50);
                
                const adaptiveLink = isLargeGraph ? linkStrength * 0.3 : linkStrength * 0.5;
                
                simulation
                    .force('center', d3.forceCenter().strength(gravityStrength))
                    .force('charge', d3.forceManyBody()
                        .strength(adaptiveCharge)
                        .distanceMax(isMassiveGraph ? 600 : isLargeGraph ? 400 : 300))
                    .force('link', d3.forceLink(connections)
                        .id(d => d.id)
                        .strength(adaptiveLink)
                        .distance(d => {
                            const sourceRadius = d.source.radius || 15;
                            const targetRadius = d.target.radius || 15;
                            const baseDistance = sourceRadius + targetRadius;
                            const spacingMultiplier = isMassiveGraph ? 6 : isLargeGraph ? 4.5 : 3.5;
                            return baseDistance + (80 * spacingMultiplier);
                        }))
                    .force('collision', d3.forceCollide()
                        .radius(d => d.radius + adaptiveCollision)
                        .strength(0.9))
                    .alphaDecay(isMassiveGraph ? 0.02 : isLargeGraph ? 0.03 : 0.028)
                    .alpha(0.1)
                    .restart();
            }
        }
        
        function toggleUI() {
            uiVisible = !uiVisible;
            const controls = document.getElementById('controls');
            const info = document.getElementById('info');
            const legend = document.querySelector('.legend');
            const toggle = document.getElementById('uiToggle');
            
            if (uiVisible) {
                controls.classList.remove('hidden');
                info.classList.remove('hidden');
                legend.classList.remove('hidden');
                toggle.classList.remove('hidden');
                toggle.textContent = 'üéõÔ∏è';
            } else {
                controls.classList.add('hidden');
                info.classList.add('hidden');
                legend.classList.add('hidden');
                toggle.classList.add('hidden');
                toggle.textContent = 'üëÅÔ∏è';
            }
            
            // Recalculate graph size after UI toggle
            setTimeout(() => {
                if (simulation) {
                    const width = window.innerWidth;
                    const height = window.innerHeight;
                    const centerX = width / 2;
                    const centerY = height / 2;
                    const boundaryRadius = Math.min(width, height) * 0.48;
                    
                    // Update boundary circle
                    if (boundaryCircle) {
                        boundaryCircle
                            .attr('cx', centerX)
                            .attr('cy', centerY)
                            .attr('r', boundaryRadius);
                    }
                    
                    // Update simulation forces
                    simulation
                        .force('center', d3.forceCenter(centerX, centerY).strength(gravityStrength))
                        .force('boundary', boundaryForce(centerX, centerY, boundaryRadius))
                        .alpha(0.3)
                        .restart();
                }
            }, 100);
        }
        
        function initializeGraph() {
            // Clear existing graph
            d3.select('#graph').selectAll('*').remove();
            
            const width = window.innerWidth;
            const height = window.innerHeight;
            const centerX = width / 2;
            const centerY = height / 2;
            // MUCH larger boundary radius for more space
            const boundaryRadius = Math.min(width, height) * 0.48;
            
            // Create SVG
            svg = d3.select('#graph')
                .attr('width', width)
                .attr('height', height);
            
            // Add gradient definitions
            const defs = svg.append('defs');
            
            // Create radial gradient for background glow
            const radialGradient = defs.append('radialGradient')
                .attr('id', 'backgroundGlow')
                .attr('cx', '50%')
                .attr('cy', '50%')
                .attr('r', '50%');
            
            radialGradient.append('stop')
                .attr('offset', '0%')
                .attr('stop-color', 'rgba(102, 126, 234, 0.1)');
            
            radialGradient.append('stop')
                .attr('offset', '100%')
                .attr('stop-color', 'rgba(102, 126, 234, 0.02)');
            
            // Create arrow markers for different connection types
            ['calls', 'inherits', 'implements', 'instantiates'].forEach(type => {
                const color = type === 'calls' ? '#45b7d1' : 
                             type === 'inherits' ? '#ff6b6b' :
                             type === 'implements' ? '#4ecdc4' : '#ffa500';
                
                defs.append('marker')
                    .attr('id', `arrowhead-${type}`)
                    .attr('viewBox', '-0 -5 10 10')
                    .attr('refX', 8)
                    .attr('refY', 0)
                    .attr('orient', 'auto')
                    .attr('markerWidth', 8)
                    .attr('markerHeight', 8)
                    .append('path')
                    .attr('d', 'M 0,-5 L 10,0 L 0,5')
                    .attr('fill', color)
                    .attr('opacity', 0.7);
            });
            
            // Add zoom behavior
            zoom = d3.zoom()
                .scaleExtent([0.1, 10])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });
            
            svg.call(zoom);
            
            // Add background circle with glow
            svg.append('circle')
                .attr('cx', centerX)
                .attr('cy', centerY)
                .attr('r', boundaryRadius)
                .attr('fill', 'url(#backgroundGlow)')
                .style('pointer-events', 'none');
            
            // Add background click handler
            svg.on('click', function(event) {
                if (event.target === this || event.target.tagName === 'svg') {
                    resetHighlight();
                }
            });
            
            // Create main group
            g = svg.append('g');
            
            // Add boundary circle
            boundaryCircle = g.append('circle')
                .attr('class', 'circular-boundary')
                .attr('cx', centerX)
                .attr('cy', centerY)
                .attr('r', boundaryRadius);
            
            // Process hierarchical data
            processData(centerX, centerY, boundaryRadius);
            
            // Create physics simulation
            createSimulation(centerX, centerY);
            
            // Render the visualization
            render();
            
            // Start periodic stats updates
            if (window.statsInterval) clearInterval(window.statsInterval);
            window.statsInterval = setInterval(updateStats, 1000);
        }
        
        function processData(centerX, centerY, boundaryRadius) {
            nodes = [];
            connections = [];
            
            if (!graphData.hierarchical) return;
            
            // Process hierarchical structure into flat format
            function processHierarchy(nodeData, parent = null, level = 0) {
                const node = {
                    id: nodeData.id,
                    name: nodeData.name,
                    type: nodeData.type,
                    file: nodeData.file,
                    line: nodeData.line,
                    children: nodeData.children || [],
                    parent: parent,
                    level: level,
                    radius: calculateRadius(nodeData),
                    x: 0,
                    y: 0,
                    fx: null,
                    fy: null
                };
                
                nodes.push(node);
                
                // Process children
                if (nodeData.children && nodeData.children.length > 0) {
                    nodeData.children.forEach(child => {
                        processHierarchy(child, node, level + 1);
                    });
                }
                
                return node;
            }
            
            // Process all root nodes
            graphData.hierarchical.forEach(root => {
                processHierarchy(root);
            });
            
            // MUCH better initial positioning with WAY more space
            const nodeCount = nodes.length;
            nodes.forEach((node, index) => {
                // Use golden ratio spiral for better distribution
                const goldenAngle = Math.PI * (3 - Math.sqrt(5));
                const theta = index * goldenAngle;
                
                // Much larger adaptive radius based on node count
                const maxRadius = boundaryRadius * 0.9; // Use more of the available space
                const spiralRadius = Math.sqrt(index / nodeCount) * maxRadius;
                
                // Add some randomization to break up perfect patterns
                const randomOffset = (Math.random() - 0.5) * 50;
                const adjustedRadius = spiralRadius + randomOffset;
                
                node.x = centerX + Math.cos(theta) * adjustedRadius;
                node.y = centerY + Math.sin(theta) * adjustedRadius;
            });
            
            // Process connections (non-containment edges)
            if (graphData.edges) {
                const nodeMap = new Map(nodes.map(n => [n.id, n]));
                
                graphData.edges.forEach(edge => {
                    if (edge.type !== 'contains' && nodeMap.has(edge.source) && nodeMap.has(edge.target)) {
                        connections.push({
                            source: edge.source,
                            target: edge.target,
                            type: edge.type
                        });
                    }
                });
            }
        }
        
        function calculateRadius(nodeData) {
            // Slightly larger radii for better visibility
            switch (nodeData.type) {
                case 'file':
                    const childCount = (nodeData.children || []).length;
                    return Math.max(45, 30 + childCount * 3);
                case 'class':
                case 'interface':
                    const methodCount = (nodeData.children || []).length;
                    return Math.max(30, 20 + methodCount * 2.5);
                case 'method':
                case 'function':
                    return 12;
                case 'import':
                    return 8;
                default:
                    return 10;
            }
        }
        
        function createSimulation(centerX, centerY) {
            const nodeCount = nodes.length;
            const boundaryRadius = Math.min(window.innerWidth, window.innerHeight) * 0.48;
            const isLargeGraph = nodeCount > 100;
            const isMassiveGraph = nodeCount > 500;
            
            console.log(`Creating simulation for ${nodeCount} nodes (${isMassiveGraph ? 'massive' : isLargeGraph ? 'large' : 'small'} graph)`);
            
            // Much stronger repulsion and spacing for better separation
            const adaptiveCharge = isMassiveGraph ? 
                Math.max(chargeStrength * 3, -900) : 
                isLargeGraph ? 
                Math.max(chargeStrength * 2, -600) : 
                chargeStrength;
            
            const adaptiveCollision = Math.max(collisionPadding * 1.5, 
                isMassiveGraph ? 80 : isLargeGraph ? 60 : 50);
            
            const adaptiveLink = isLargeGraph ? linkStrength * 0.3 : linkStrength * 0.5;
            const adaptiveGravity = Math.max(0.002, gravityStrength / Math.sqrt(nodeCount / 5));
            
            simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(connections)
                    .id(d => d.id)
                    .strength(adaptiveLink)
                    .distance(d => {
                        const sourceRadius = d.source.radius || 15;
                        const targetRadius = d.target.radius || 15;
                        const baseDistance = sourceRadius + targetRadius;
                        // Much larger spacing multipliers
                        const spacingMultiplier = isMassiveGraph ? 6 : isLargeGraph ? 4.5 : 3.5;
                        return baseDistance + (80 * spacingMultiplier);
                    }))
                .force('charge', d3.forceManyBody()
                    .strength(adaptiveCharge)
                    .distanceMax(isMassiveGraph ? 600 : isLargeGraph ? 400 : 300))
                .force('center', d3.forceCenter(centerX, centerY).strength(adaptiveGravity))
                .force('collision', d3.forceCollide()
                    .radius(d => d.radius + adaptiveCollision)
                    .strength(0.9)) // Stronger collision detection
                .force('boundary', boundaryForce(centerX, centerY, boundaryRadius))
                .alphaDecay(isMassiveGraph ? 0.08 : isLargeGraph ? 0.06 : 0.04) // Faster decay to settle sooner
                .alphaMin(0.001) // Higher minimum to stop sooner
                .on('tick', throttledTick)
                .on('end', () => {
                    isSimulationCooled = true;
                    console.log('Simulation settled - nodes locked in position');
                    // Lock all nodes in position once simulation ends
                    nodes.forEach(node => {
                        node.fx = node.x;
                        node.fy = node.y;
                    });
                });
                
            // Auto-stop simulation faster for better stability
            setTimeout(() => {
                if (simulation && simulation.alpha() > 0.01) {
                    simulation.alpha(0.001); // Force stop
                    console.log('Force stopping simulation to prevent endless movement');
                    // Lock all nodes in position
                    nodes.forEach(node => {
                        node.fx = node.x;
                        node.fy = node.y;
                    });
                }
            }, isMassiveGraph ? 6000 : isLargeGraph ? 4000 : 3000); // Shorter timeouts
        }
        
        // Throttled tick function for better performance
        function throttledTick() {
            const now = Date.now();
            if (now - lastTickTime >= tickThrottle) {
                lastTickTime = now;
                updatePositions();
            }
        }
        
        function boundaryForce(centerX, centerY, radius) {
            return function(alpha) {
                nodes.forEach(node => {
                    const dx = node.x - centerX;
                    const dy = node.y - centerY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // More gentle boundary with larger buffer
                    const boundaryBuffer = node.radius + 20;
                    if (distance > radius - boundaryBuffer) {
                        const factor = (radius - boundaryBuffer) / distance;
                        node.x = centerX + dx * factor;
                        node.y = centerY + dy * factor;
                    }
                });
            };
        }
        
        function render() {
            // Create connection lines first (so they appear behind circles)
            if (showConnections) {
                connectionElements = g.selectAll('.connection-line')
                    .data(connections)
                    .enter()
                    .append('line')
                    .attr('class', d => `connection-line connection-${d.type}`)
                    .attr('marker-end', d => `url(#arrowhead-${d.type})`)
                    .on('mouseover', showConnectionTooltip)
                    .on('mouseout', hideTooltip);
            }
            
            // Create circles
            circleElements = g.selectAll('.circle-node')
                .data(nodes)
                .enter()
                .append('circle')
                .attr('class', d => `circle-node circle-${d.type}`)
                .attr('r', d => d.radius)
                .attr('fill', d => colorMap[d.type] || '#999')
                .attr('stroke', d => colorMap[d.type] || '#999')
                .on('click', showNodeInfo)
                .on('mouseover', showNodeTooltip)
                .on('mouseout', hideTooltip);
                // Removed drag behavior - nodes are not draggable
            
            // Create labels
            labelElements = g.selectAll('.node-label')
                .data(nodes)
                .enter()
                .append('text')
                .attr('class', d => d.type === 'file' || d.type === 'class' ? 'container-label' : 'node-label')
                .text(d => {
                    const maxLength = d.type === 'file' ? 25 : d.type === 'class' ? 20 : 15;
                    return d.name.length > maxLength ? d.name.substring(0, maxLength - 3) + '...' : d.name;
                })
                .style('pointer-events', 'none');
                
            updatePositions();
        }
        
        function updatePositions() {
            // Use transforms instead of setting cx/cy attributes for better performance
            if (circleElements) {
                circleElements.attr('transform', d => `translate(${d.x},${d.y})`);
            }
            
            if (labelElements) {
                labelElements.attr('transform', d => `translate(${d.x},${d.y})`);
            }
            
            // Only update connections if they're visible
            if (connectionElements && showConnections) {
                connectionElements
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
            }
        }
        
        // Control functions for physics management
        function togglePhysics() {
            physicsEnabled = !physicsEnabled;
            const btn = document.getElementById('physicsBtn');
            const checkbox = document.getElementById('enablePhysics');
            
            if (physicsEnabled) {
                // Unlock nodes for physics
                nodes.forEach(node => {
                    node.fx = null;
                    node.fy = null;
                });
                simulation?.alpha(0.1).restart();
                btn.classList.add('active');
                btn.textContent = '‚ö° Physics ON';
                checkbox.checked = true;
            } else {
                // Lock nodes in current position
                nodes.forEach(node => {
                    node.fx = node.x;
                    node.fy = node.y;
                });
                simulation?.stop();
                btn.classList.remove('active');
                btn.textContent = '‚ö° Physics OFF';
                checkbox.checked = false;
            }
        }
        
        function resetPositions() {
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const boundaryRadius = Math.min(window.innerWidth, window.innerHeight) * 0.48;
            
            const nodeCount = nodes.length;
            
            // Use golden ratio spiral for optimal distribution with much more spacing
            nodes.forEach((node, index) => {
                const goldenAngle = Math.PI * (3 - Math.sqrt(5));
                const theta = index * goldenAngle;
                const maxRadius = boundaryRadius * 0.9;
                const spiralRadius = Math.sqrt(index / nodeCount) * maxRadius;
                
                // Add randomization to prevent overlapping
                const randomOffset = (Math.random() - 0.5) * 50;
                const adjustedRadius = spiralRadius + randomOffset;
                
                node.x = centerX + Math.cos(theta) * adjustedRadius;
                node.y = centerY + Math.sin(theta) * adjustedRadius;
                node.fx = null; // Unlock temporarily
                node.fy = null;
            });
            
            if (simulation && physicsEnabled) {
                simulation.alpha(0.3).restart();
                // Auto-lock after settling
                setTimeout(() => {
                    nodes.forEach(node => {
                        node.fx = node.x;
                        node.fy = node.y;
                    });
                }, 3000);
            } else {
                // If physics disabled, lock immediately in new positions
                nodes.forEach(node => {
                    node.fx = node.x;
                    node.fy = node.y;
                });
                updatePositions();
            }
        }
        
        function showNodeInfo(event, d) {
            // Calculate connections for this node
            const connectionsOut = connections.filter(c => c.source.id === d.id || c.source === d.id);
            const connectionsIn = connections.filter(c => c.target.id === d.id || c.target === d.id);
            
            let info = `
                <strong>Name:</strong> ${d.name}<br>
                <strong>Type:</strong> ${d.type}<br>
                <strong>File:</strong> ${d.file || 'N/A'}<br>
                <strong>Line:</strong> ${d.line || 'N/A'}<br>
            `;
            
            if (d.parent) {
                info += `<strong>Parent:</strong> ${d.parent.name}<br>`;
            }
            
            if (d.children && d.children.length > 0) {
                info += `<strong>Children:</strong> ${d.children.length}<br>`;
            }
            
            // Group connections by type
            const outgoing = {};
            const incoming = {};
            
            connectionsOut.forEach(c => {
                outgoing[c.type] = (outgoing[c.type] || 0) + 1;
            });
            
            connectionsIn.forEach(c => {
                incoming[c.type] = (incoming[c.type] || 0) + 1;
            });
            
            if (Object.keys(outgoing).length > 0 || Object.keys(incoming).length > 0) {
                info += '<br><strong>Connections:</strong><br>';
                
                Object.entries(outgoing).forEach(([type, count]) => {
                    info += `‚Ä¢ ${type}: ${count} outgoing<br>`;
                });
                
                Object.entries(incoming).forEach(([type, count]) => {
                    info += `‚Ä¢ ${type}: ${count} incoming<br>`;
                });
            }
            
            document.getElementById('nodeInfo').innerHTML = info;
            
            // Highlight this node and its connections
            highlightNode(d);
        }
        
        function highlightNode(targetNode) {
            // Reset all styles
            resetHighlight();
            
            // Find connected nodes
            const connectedNodeIds = new Set([targetNode.id]);
            const relevantConnections = [];
            
            connections.forEach(connection => {
                const sourceId = connection.source.id || connection.source;
                const targetId = connection.target.id || connection.target;
                
                if (sourceId === targetNode.id || targetId === targetNode.id) {
                    connectedNodeIds.add(sourceId);
                    connectedNodeIds.add(targetId);
                    relevantConnections.push(connection);
                }
            });
            
            // Highlight relevant nodes
            circleElements.classed('highlighted', d => d.id === targetNode.id)
                          .classed('dimmed', d => !connectedNodeIds.has(d.id));
            
            // Highlight relevant connections
            if (connectionElements) {
                connectionElements.classed('highlighted', d => {
                    const sourceId = d.source.id || d.source;
                    const targetId = d.target.id || d.target;
                    return sourceId === targetNode.id || targetId === targetNode.id;
                }).classed('dimmed', d => {
                    const sourceId = d.source.id || d.source;
                    const targetId = d.target.id || d.target;
                    return sourceId !== targetNode.id && targetId !== targetNode.id;
                });
            }
            
            // Highlight labels
            labelElements.classed('dimmed', d => !connectedNodeIds.has(d.id));
        }
        
        function resetHighlight() {
            circleElements?.classed('highlighted', false).classed('dimmed', false);
            connectionElements?.classed('highlighted', false).classed('dimmed', false);
            labelElements?.classed('dimmed', false);
        }
        
        function showNodeTooltip(event, d) {
            const tooltip = d3.select('.tooltip');
            tooltip.html(`${d.name} (${d.type})`)
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 10) + 'px')
                .style('opacity', 1);
        }
        
        function showConnectionTooltip(event, d) {
            const tooltip = d3.select('.tooltip');
            const sourceName = d.source.name || d.source;
            const targetName = d.target.name || d.target;
            tooltip.html(`${sourceName} ‚Üí ${targetName}<br><em>${d.type}</em>`)
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 10) + 'px')
                .style('opacity', 1);
        }
        
        function hideTooltip() {
            d3.select('.tooltip').style('opacity', 0);
        }
        
        function zoomIn() {
            svg.transition().duration(300).call(zoom.scaleBy, 1.3);
        }
        
        function zoomOut() {
            svg.transition().duration(300).call(zoom.scaleBy, 0.7);
        }
        
        function resetZoom() {
            svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity);
        }
        
        function centerGraph() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            svg.transition().duration(750).call(
                zoom.transform,
                d3.zoomIdentity.translate(width / 2, height / 2).scale(1)
            );
        }
        
        function toggleConnections() {
            showConnections = !showConnections;
            
            if (connectionElements) {
                connectionElements.style('display', showConnections ? 'block' : 'none');
            }
        }
        
        function highlightCrossFileConnections() {
            if (!connections || connections.length === 0) return;
            
            resetHighlight();
            
            const crossFileConnections = connections.filter(c => {
                const source = c.source.file || c.source;
                const target = c.target.file || c.target;
                return source !== target;
            });
            
            const involvedNodeIds = new Set();
            
            crossFileConnections.forEach(c => {
                const sourceId = c.source.id || c.source;
                const targetId = c.target.id || c.target;
                involvedNodeIds.add(sourceId);
                involvedNodeIds.add(targetId);
            });
            
            // Highlight cross-file connections and involved nodes
            circleElements.classed('dimmed', d => !involvedNodeIds.has(d.id));
            
            if (connectionElements) {
                connectionElements.classed('highlighted', d => {
                    const source = d.source.file || d.source;
                    const target = d.target.file || d.target;
                    return source !== target;
                }).classed('dimmed', d => {
                    const source = d.source.file || d.source;
                    const target = d.target.file || d.target;
                    return source === target;
                });
            }
            
            labelElements.classed('dimmed', d => !involvedNodeIds.has(d.id));
            
            document.getElementById('nodeInfo').innerHTML = `
                <strong>Cross-File Connections:</strong><br>
                Found ${crossFileConnections.length} connections between different files.<br><br>
                <em>These show how different parts of your codebase interact.</em>
            `;
        }
        
        // Search functionality
        document.getElementById('search').addEventListener('input', function(e) {
            const searchTerm = e.target.value.toLowerCase();
            
            if (searchTerm === '') {
                resetHighlight();
            } else {
                const matchingNodeIds = new Set();
                nodes.forEach(node => {
                    if (node.name.toLowerCase().includes(searchTerm)) {
                        matchingNodeIds.add(node.id);
                    }
                });
                
                circleElements.classed('dimmed', d => !matchingNodeIds.has(d.id));
                labelElements.classed('dimmed', d => !matchingNodeIds.has(d.id));
                
                if (connectionElements) {
                    connectionElements.classed('dimmed', true);
                }
            }
        });
        
        // Filter by type
        ['Files', 'Classes', 'Methods', 'Functions', 'Imports'].forEach(type => {
            const checkbox = document.getElementById(`show${type}`);
            if (checkbox) {
                checkbox.addEventListener('change', function(e) {
                    const typeKey = type.toLowerCase().slice(0, -1);
                    
                    circleElements.each(function(d) {
                        if (d.type === typeKey) {
                            d3.select(this).style('display', e.target.checked ? 'block' : 'none');
                        }
                    });
                    
                    labelElements.each(function(d) {
                        if (d.type === typeKey) {
                            d3.select(this).style('display', e.target.checked ? 'block' : 'none');
                        }
                    });
                });
            }
        });
        
        function updateStats() {
            if (!graphData) return;
            
            const nodeCount = nodes.length;
            const isLargeGraph = nodeCount > 100;
            const isMassiveGraph = nodeCount > 500;
            
            const stats = {
                nodes: nodeCount,
                connections: connections.length,
                files: nodes.filter(n => n.type === 'file').length,
                classes: nodes.filter(n => n.type === 'class').length,
                methods: nodes.filter(n => n.type === 'method').length,
                functions: nodes.filter(n => n.type === 'function').length,
                crossFileConnections: connections.filter(c => {
                    const source = c.source.file || c.source;
                    const target = c.target.file || c.target;
                    return source !== target;
                }).length
            };
            
            let statsHtml = `
                <div class="section-title">Statistics</div>
                üìä Nodes: ${stats.nodes}<br>
                üîó Connections: ${stats.connections}<br>
                üìÑ Files: ${stats.files}<br>
                üèóÔ∏è Classes: ${stats.classes}<br>
                ‚öôÔ∏è Methods: ${stats.methods}<br>
                üîß Functions: ${stats.functions}<br>
                üåê Cross-file: ${stats.crossFileConnections}<br>
                ${isMassiveGraph ? 'üöÄ <span style="color: #ff6b6b;">Massive Graph Mode</span>' : 
                  isLargeGraph ? '‚ö° <span style="color: #ffa500;">Large Graph Mode</span>' : 
                  '‚ú® Standard Mode'}
            `;
            
            if (simulation) {
                const alpha = simulation.alpha();
                const status = alpha < 0.005 ? 'Settled' : alpha < 0.05 ? 'Cooling' : 'Active';
                statsHtml += `<br>üéØ Physics: ${status}`;
            }
            
            if (graphData.external_dependencies && graphData.external_dependencies.length > 0) {
                const uniqueExternal = new Set(graphData.external_dependencies.map(d => d.target));
                statsHtml += `<br>üì¶ External deps: ${uniqueExternal.size}`;
            }
            
            document.getElementById('stats').innerHTML = statsHtml;
        }
        
        // Optimized resize handler with debouncing
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                const width = window.innerWidth;
                const height = window.innerHeight;
                svg?.attr('width', width).attr('height', height);
                
                const centerX = width / 2;
                const centerY = height / 2;
                const boundaryRadius = Math.min(width, height) * 0.48;
                
                // Update boundary circle
                if (boundaryCircle) {
                    boundaryCircle
                        .attr('cx', centerX)
                        .attr('cy', centerY)
                        .attr('r', boundaryRadius);
                }
                
                // Gently update simulation forces
                if (simulation && physicsEnabled) {
                    const nodeCount = nodes.length;
                    const adaptiveGravity = Math.max(0.002, gravityStrength / Math.sqrt(nodeCount / 5));
                    
                    simulation
                        .force('center', d3.forceCenter(centerX, centerY).strength(adaptiveGravity))
                        .force('boundary', boundaryForce(centerX, centerY, boundaryRadius))
                        .alpha(0.1) // Gentle restart
                        .restart();
                }
            }, 250); // Debounce resize events
        });
        
        // Initialize with demo message
        document.getElementById('nodeInfo').innerHTML = `
            <p>üöÄ Load a <code>code_graph.json</code> file to explore your code with <strong>stable physics visualization</strong>!</p>
            <br>
            <p><strong>üîß Key Features:</strong></p>
            <ul style="font-size: 13px; margin-left: -15px; line-height: 1.6;">
                <li>‚úÖ Nodes automatically lock in place when settled</li>
                <li>‚úÖ No dragging or endless movement</li>
                <li>‚úÖ Physics stops after optimal layout is found</li>
                <li>‚úÖ Much stronger repulsion forces (3x stronger)</li>
                <li>‚úÖ Larger collision padding (40-80px)</li>
                <li>‚úÖ Better initial positioning with randomization</li>
                <li>‚úÖ Adaptive spacing for different graph sizes</li>
                <li>‚úÖ Faster settling (3-6 seconds max)</li>
            </ul>
            <br>
            <p><strong>üí° How It Works:</strong></p>
            <ul style="font-size: 13px; margin-left: -15px; line-height: 1.6;">
                <li>üéØ Physics runs briefly to find optimal layout</li>
                <li>üîí Nodes automatically lock in final positions</li>
                <li>üëÜ Click nodes to see info (no dragging)</li>
                <li>üîÑ Use "Scatter" to randomize and re-settle</li>
                <li>‚ö° Toggle physics to unlock/lock positions</li>
            </ul>
        `;
    </script>
</body>
</html>